node.go :
- add dbKey, path, leftchilddbkey rightchilddbkey
- MakeNode() unmarshal leftChildDBKey, rightChildDBKey after lefthash and righthash
- GetKey() return node.dbkey instead of node.hash
- clone() clone node.leftChildDBKey and node.rightChildDBKey
- validate() validate leftChildDBKey and rightChildDBKey
- encodedSize() + size of leftKey and rightKey
- writeBytes() marshal leftKey and rightKey after lefthash and righthash
- String() blablabla

nodedb.go :
- GetNode(hash []byte) -> GetNode(key []byte) should takes new dbkey instead of hash
 GetNode() used by 
 - deleteNodesFrom
 - getleft and right node
 - remove // recursiveRemove -> tree.ndb.GetNode(newRootHash) *
 - LazyLoadVersion // iTree.root, err = tree.ndb.GetNode(rootHash)

 - LoadVersion // t.root, err = tree.ndb.GetNode(latestRoot)
 - GetImmutable // 	root, err := tree.ndb.GetNode(rootHash)
node.hash used to set by the hash passed in, not anymore
ndb.nodeCache.Add(node) node here is a pointer so were good
- SaveNode(node *Node) 
 use node.GetKey instead of node.hash
- Has(dbKey []byte) 
used by some of the tests
- SaveBranch(node *Node) now set path for node recursively, set dbkey for node and use dbkey instead of hash
- deleteNodesFrom(version int64, dbKey []byte)
 used by
 - DeleteVersionsFrom

 






should I set store path ? idk I guess no for now

why they set hash ? 

they set store in balance

make sure dkey is set
